# remove other variables
rm(list = ls())

# import the LBA r package
require(rtdists)

# FUNCTIONS ----

# this function makes sure that mean_v and sd_v have the same length as RT and responses
# the function is adopted from the GitHub page, no alterations were made
check_i_arguments <- function(arg, nn, n_v, dots = FALSE) {
  mc <- match.call()
  varname <- sub("dots$", "", deparse(mc[["arg"]]), fixed = TRUE)
  if (!is.list(arg)) {
    if ((!is.vector(arg, "numeric")) || (length(arg) < 1)) 
      stop(paste(varname, "needs to be a numeric vector of length >= 1!"))
    if (dots) {
      arg <- as.list(arg)
      arg <- lapply(arg, rep, length.out=nn)
    } else arg <- lapply(seq_len(n_v), function(x) rep(arg, length.out=nn))
  } else {
    if (!dots && (length(arg) != n_v)) 
      stop(paste("if", varname, "is a list, its length needs to correspond to the number of accumulators."))
    for (i in seq_along(arg)) {
      if ((!is.vector(arg[[i]], "numeric")) || (length(arg[[i]]) < 1)) 
        stop(paste0(varname, "[[", i, "]] needs to be a numeric vector of length >= 1!"))
      arg[[i]] <- rep(arg[[i]], length.out=nn)
    }
  }
  #if (length(arg) != n_v) stop(paste("size of", varname, "does not correspond to number of accumulators."))
  return(arg)
}

# dLBA after alterations were made
# specifically, lines 65 - 75 have been altered to allow passing of the netinputs
dLBA <-  function(rt, response, A, b, t0, ..., st0=0, 
                  distribution = c("norm", "gamma", "frechet", "lnorm"), 
                  args.dist = list(), silent = FALSE) {
  dots <- list(...)
  if (is.null(names(dots))) stop("... arguments need to be named.")
  
  # for convenience accept data.frame as first argument.
  if (is.data.frame(rt)) {
    response <- rt$response
    rt <- rt$rt
  }
  
  response <- as.numeric(response)
  nn <- length(rt)
  n_v <- max(vapply(dots, length, 0))  # Number of responses
  if(!silent) 
    message(paste("Results based on", n_v, "accumulators/drift rates."))
  if (!is.numeric(response) || max(response) > n_v) 
    stop("response needs to be a numeric vector of integers up to number of accumulators.")
  if (any(response < 1)) 
    stop("the first response/accumulator must have value 1.")
  if (n_v < 2) 
    stop("There need to be at least two accumulators/drift rates.")
  distribution <- match.arg(distribution)
  response <- rep(response, length.out = nn)
  A <- check_i_arguments(A, nn=nn, n_v=n_v)
  b <- check_i_arguments(b, nn=nn, n_v=n_v)
  t0 <- check_i_arguments(t0, nn=nn, n_v=n_v)
  switch(distribution, 
         norm = {
           if (any(!(c("mean_v","sd_v") %in% names(dots)))) 
             stop("mean_v and sd_v need to be passed for distribution = \"norm\"")
           if((length(dots$mean_v) != n_v) & (length(dots$mean_v) != nn)){
             stop("mean_v should be of length RT, or the number of accumulators")
           }
           if (length(dots$mean_v) == n_v){
             dots$mean_v <- check_i_arguments(dots$mean_v, nn=nn, n_v=n_v, dots = TRUE)
           }
           dots$sd_v <- check_i_arguments(dots$sd_v, nn=nn, n_v=n_v, dots = TRUE)
           dots <- dots[c("mean_v","sd_v")]
         },
         gamma = {
           if (!("shape_v" %in% names(dots))) 
             stop("shape_v needs to be passed for distribution = \"gamma\"")
           if ((!("rate_v" %in% names(dots))) & (!("scale_v" %in% names(dots)))) 
             stop("rate_v or scale_v need to be passed for distribution = \"gamma\"")
           dots$shape_v <- check_i_arguments(dots$shape_v, nn=nn, n_v=n_v, dots = TRUE)
           if ("scale_v" %in% names(dots)) {
             dots$scale_v <- check_i_arguments(dots$scale_v, nn=nn, n_v=n_v, dots = TRUE)
             if (is.list(dots$scale_v)) {
               dots$rate_v <- lapply(dots$scale_v, function(x) 1/x)
             } else dots$rate_v <- 1/dots$scale_v
           } else dots$rate_v <- check_i_arguments(dots$rate_v, nn=nn, n_v=n_v, dots = TRUE)
           dots <- dots[c("shape_v","rate_v")]
         },
         frechet = {
           if (any(!(c("shape_v","scale_v") %in% names(dots)))) 
             stop("shape_v and scale_v need to be passed for distribution = \"frechet\"")
           dots$shape_v <- check_i_arguments(dots$shape_v, nn=nn, n_v=n_v, dots = TRUE)
           dots$scale_v <- check_i_arguments(dots$scale_v, nn=nn, n_v=n_v, dots = TRUE)
           dots <- dots[c("shape_v","scale_v")]
         },
         lnorm = {
           if (any(!(c("meanlog_v","sdlog_v") %in% names(dots)))) 
             stop("meanlog_v and sdlog_v need to be passed for distribution = \"lnorm\"")
           dots$meanlog_v <- check_i_arguments(dots$meanlog_v, nn=nn, n_v=n_v, dots = TRUE)
           dots$sdlog_v <- check_i_arguments(dots$sdlog_v, nn=nn, n_v=n_v, dots = TRUE)
           dots <- dots[c("meanlog_v","sdlog_v")]
         }
  )
  #browser()
  for (i in seq_len(length(dots))) {
    if (length(dots[[i]]) < n_v) dots[[i]] <- rep(dots[[i]],length.out=n_v)
  }
  out <- vector("numeric", nn)
  for (i in unique(response)) {
    sel <- response == i
    out[sel] <- do.call(n1PDF, 
                        args = c(rt=list(rt[sel]), 
                                 A = list(lapply(A, "[", i = sel)[c(i, seq_len(n_v)[-i])]), 
                                 b = list(lapply(b, "[", i = sel)[c(i, seq_len(n_v)[-i])]),
                                 t0 = list(lapply(t0, "[", i = sel)[c(i, seq_len(n_v)[-i])]),
                                 lapply(dots, function(x) 
                                   lapply(x, "[", i = sel)[c(i, seq_len(n_v)[-i])]), 
                                 distribution=distribution, 
                                 args.dist=list(args.dist), 
                                 silent=TRUE, st0 = list(st0)))
  }
  return(out)
}

# TEST ----

# get initial guess for LBA parameters
get_start_lba <- function(){
  return(runif(1, 0, 1))
}

# load data
datapath = "C:/Users/pieter/Downloads/GitHub/phuycke/PhD-code/Modeling/LBA/R/Data/RW data/Varying beta (2000 trials)"
filename = "Varying beta (2000 trials) RW LBA (LR 0.10; N = 2000; stamp = 21386.42).rda"
load(paste(datapath, filename, sep="/"))
rm(datapath, filename)

# convert to dataframe
if (class(df) != "data.frame"){
  df = data.frame(df)
}

# parameters used for LBA process
to_optim     = c(.5)
rt           = df$rt
response     = df$response
distribution = "norm"

# change of parameters required to pass to dLBA
par = c(A = .6, b = 1, t0 = .5, 
        mean_v1 = to_optim, mean_v2 = 1-to_optim, sd_v2 = 1)
spar = par[!grepl("[12]$", names(par))]  
dist_par_names <- unique(sub("[12]$", "", grep("[12]$" ,names(par), value = TRUE)))
dist_par <- vector("list", length = length(dist_par_names))
names(dist_par) <- dist_par_names
for (i in dist_par_names) dist_par[[i]] <- as.list(unname(par[grep(i, names(par))]))
dist_par$sd_v <- c(dist_par$sd_v, dist_par$sd_v) # set common sd's
dist_par$mean_v = list(df$mean_v1, df$mean_v2)

# run LBA and see whether it works out 
d = do.call(dLBA, args = c(rt=list(rt), response=list(response), spar, dist_par, 
                           distribution=distribution, silent=TRUE))
if (any(d < 0e-10)){
  d = 1e6
} else{
  d = -sum(log(d))
}
cat("Calculated -LL based on parameters:", d)

# the original function dLBA can be adjusted using the above code using 
# trace("dLBA", edit = T)

